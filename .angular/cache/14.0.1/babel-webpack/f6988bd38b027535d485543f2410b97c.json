{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { ElementRef, Component, ViewChild, Input, NgModule, PlatformRef, VERSION, enableProdMode, NgZone } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { __awaiter } from 'tslib';\nimport * as i1 from '@angular/router';\nimport { Router } from '@angular/router';\nimport { loadRemoteModule } from '@angular-architects/module-federation';\nimport { platformBrowser } from '@angular/platform-browser'; // eslint-disable-next-line @angular-eslint/component-class-suffix\n\nconst _c0 = [\"vc\"];\nlet WebComponentWrapper = /*#__PURE__*/(() => {\n  class WebComponentWrapper {\n    constructor(route) {\n      this.route = route;\n    }\n\n    ngOnChanges() {\n      if (!this.element) return;\n      this.populateProps();\n    }\n\n    populateProps() {\n      for (const prop in this.props) {\n        this.element[prop] = this.props[prop];\n      }\n    }\n\n    setupEvents() {\n      for (const event in this.events) {\n        this.element.addEventListener(event, this.events[event]);\n      }\n    }\n\n    ngAfterContentInit() {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, function* () {\n        const options = (_a = this.options) !== null && _a !== void 0 ? _a : this.route.snapshot.data;\n\n        try {\n          yield loadRemoteModule(options);\n          this.element = document.createElement(options.elementName);\n          this.populateProps();\n          this.setupEvents();\n          this.vc.nativeElement.appendChild(this.element);\n        } catch (error) {\n          console.error(error);\n        }\n      });\n    }\n\n  }\n\n  WebComponentWrapper.ɵfac = function WebComponentWrapper_Factory(t) {\n    return new (t || WebComponentWrapper)(i0.ɵɵdirectiveInject(i1.ActivatedRoute));\n  };\n\n  WebComponentWrapper.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: WebComponentWrapper,\n    selectors: [[\"mft-wc-wrapper\"]],\n    viewQuery: function WebComponentWrapper_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7, ElementRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.vc = _t.first);\n      }\n    },\n    inputs: {\n      options: \"options\",\n      props: \"props\",\n      events: \"events\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 0,\n    consts: [[\"vc\", \"\"]],\n    template: function WebComponentWrapper_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", null, 0);\n      }\n    },\n    encapsulation: 2\n  });\n  return WebComponentWrapper;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ModuleFederationToolsModule = /*#__PURE__*/(() => {\n  class ModuleFederationToolsModule {}\n\n  ModuleFederationToolsModule.ɵfac = function ModuleFederationToolsModule_Factory(t) {\n    return new (t || ModuleFederationToolsModule)();\n  };\n\n  ModuleFederationToolsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ModuleFederationToolsModule\n  });\n  ModuleFederationToolsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return ModuleFederationToolsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst packageNamespace = '@angular-architects/module-federation-tools';\n\nfunction getGlobalState() {\n  const globalState = window;\n  globalState[packageNamespace] = globalState[packageNamespace] || {};\n  return globalState[packageNamespace];\n}\n\nfunction getGlobalStateSlice(selector) {\n  const globalState = getGlobalState();\n  return selector ? selector(globalState) : globalState;\n}\n\nfunction setGlobalStateSlice(slice) {\n  return Object.assign(getGlobalState(), slice);\n}\n\nfunction startsWith(prefix) {\n  return url => {\n    const fullUrl = url.map(u => u.path).join('/');\n\n    if (fullUrl.startsWith(prefix)) {\n      return {\n        consumed: url\n      };\n    }\n\n    return null;\n  };\n}\n\nfunction endsWith(prefix) {\n  return url => {\n    const fullUrl = url.map(u => u.path).join('/');\n\n    if (fullUrl.endsWith(prefix)) {\n      return {\n        consumed: url\n      };\n    }\n\n    return null;\n  };\n}\n\nfunction connectRouter(router, useHash = false) {\n  let url;\n\n  if (!useHash) {\n    url = `${location.pathname.substr(1)}${location.search}`;\n    router.navigateByUrl(url);\n    window.addEventListener('popstate', () => {\n      router.navigateByUrl(url);\n    });\n  } else {\n    url = `${location.hash.substr(1)}${location.search}`;\n    router.navigateByUrl(url);\n    window.addEventListener('hashchange', () => {\n      router.navigateByUrl(url);\n    });\n  }\n}\n\nlet ngZoneSharing = true;\nlet platformSharing = true;\nlet legacyMode = true;\n\nfunction getMajor(version) {\n  const pre = version.match(/\\d+/)[0];\n  const post = version.match(/-.*/);\n\n  if (!pre) {\n    throw new Error('Cound not identify major version: ' + version);\n  }\n\n  if (post) {\n    return pre + post[0];\n  }\n\n  return pre;\n}\n\nfunction getLegacyPlatformCache() {\n  const platformCache = window;\n  platformCache.platform = platformCache.platform || {};\n  return platformCache;\n}\n\nfunction getLegacyPlatform(key) {\n  const platform = getLegacyPlatformCache().platform[key];\n  /**\r\n   * If dependencies are not shared, platform with same version is different\r\n   * and shared platform will not be returned.\r\n   */\n\n  return platform instanceof PlatformRef ? platform : null;\n}\n\nfunction setLegacyPlatform(key, platform) {\n  getLegacyPlatformCache().platform[key] = platform;\n}\n\nfunction getLegacyNgZone() {\n  return window['ngZone'];\n}\n\nfunction setLegacyNgZone(zone) {\n  window['ngZone'] = zone;\n}\n/**\r\n * LEGACY IMPLEMENTATIONS END\r\n */\n\n\nfunction getPlatformCache() {\n  return getGlobalStateSlice(state => state.platformCache) || setGlobalStateSlice({\n    platformCache: new Map()\n  }).platformCache;\n}\n\nfunction setPlatform(version, platform) {\n  if (platformSharing) {\n    legacyMode && setLegacyPlatform(version.full, platform);\n    getPlatformCache().set(version, platform);\n  }\n}\n\nfunction getPlatform(options) {\n  if (!platformSharing) {\n    return options.platformFactory();\n  }\n\n  const versionResult = options.version();\n  const version = versionResult === VERSION.full ? VERSION : versionResult;\n  const versionKey = typeof version === 'string' ? version : version.full;\n  let platform = getPlatformCache().get(version) || legacyMode && getLegacyPlatform(versionKey);\n\n  if (!platform) {\n    platform = options.platformFactory();\n    setPlatform(VERSION, platform);\n  }\n\n  return platform;\n}\n\nfunction getNgZone() {\n  return getGlobalStateSlice(state => state.ngZone) || getLegacyNgZone();\n}\n\nfunction shareNgZone(zone) {\n  if (ngZoneSharing) {\n    legacyMode && setLegacyNgZone(zone);\n    setGlobalStateSlice({\n      ngZone: zone\n    });\n  }\n}\n\nfunction bootstrap(module, options) {\n  var _a;\n\n  ngZoneSharing = options.ngZoneSharing !== false;\n  platformSharing = options.platformSharing !== false;\n  legacyMode = options.activeLegacyMode !== false;\n\n  options.platformFactory = options.platformFactory || (() => platformBrowser());\n\n  options.version = options.version || (() => VERSION);\n\n  options.production && enableProdMode();\n\n  if (ngZoneSharing && !((_a = options.compilerOptions) === null || _a === void 0 ? void 0 : _a.ngZone)) {\n    options.compilerOptions = options.compilerOptions || {};\n    options.compilerOptions.ngZone = getNgZone();\n  }\n\n  return getPlatform(options).bootstrapModule(module, options.compilerOptions).then(ref => {\n    if (options.appType === 'shell') {\n      shareShellZone(ref.injector);\n    } else if (options.appType === 'microfrontend') {\n      connectMicroFrontendRouter(ref.injector);\n    }\n\n    return ref;\n  });\n}\n\nfunction shareShellZone(injector) {\n  const ngZone = injector.get(NgZone, null);\n\n  if (!ngZone) {\n    console.warn('No NgZone to share found');\n    return;\n  }\n\n  shareNgZone(ngZone);\n}\n\nfunction connectMicroFrontendRouter(injector) {\n  const router = injector.get(Router);\n\n  if (!router) {\n    console.warn('No router to connect found');\n    return;\n  }\n\n  connectRouter(router);\n}\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { ModuleFederationToolsModule, WebComponentWrapper, bootstrap, connectRouter, endsWith, getMajor, shareNgZone, startsWith }; //# sourceMappingURL=angular-architects-module-federation-tools.js.map","map":null,"metadata":{},"sourceType":"module"}