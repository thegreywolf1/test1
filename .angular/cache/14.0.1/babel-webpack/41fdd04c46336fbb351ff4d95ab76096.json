{"ast":null,"code":"import { __awaiter } from 'tslib';\nlet config = {};\nconst containerMap = {};\nconst remoteMap = {};\nlet isDefaultScopeInitialized = false;\n\nfunction lookupExposedModule(key, exposedModule) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const container = containerMap[key];\n    const factory = yield container.get(exposedModule);\n    const Module = factory();\n    return Module;\n  });\n}\n\nfunction initRemote(container, key) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // const container = window[key] as Container;\n    // Do we still need to initialize the remote?\n    if (remoteMap[key]) {\n      return container;\n    } // Do we still need to initialize the share scope?\n\n\n    if (!isDefaultScopeInitialized) {\n      yield __webpack_init_sharing__('default');\n      isDefaultScopeInitialized = true;\n    }\n\n    yield container.init(__webpack_share_scopes__.default);\n    remoteMap[key] = true;\n    return container;\n  });\n}\n\nfunction loadRemoteEntry(remoteEntryOrOptions, remoteName) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (typeof remoteEntryOrOptions === 'string') {\n      const remoteEntry = remoteEntryOrOptions;\n      return yield loadRemoteScriptEntry(remoteEntry, remoteName);\n    } else if (remoteEntryOrOptions.type === 'script') {\n      const options = remoteEntryOrOptions;\n      return yield loadRemoteScriptEntry(options.remoteEntry, options.remoteName);\n    } else if (remoteEntryOrOptions.type === 'module') {\n      const options = remoteEntryOrOptions;\n      yield loadRemoteModuleEntry(options.remoteEntry);\n    }\n  });\n}\n\nfunction loadRemoteModuleEntry(remoteEntry) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (containerMap[remoteEntry]) {\n      return Promise.resolve();\n    }\n\n    return yield import(\n    /* webpackIgnore:true */\n    remoteEntry).then(container => {\n      initRemote(container, remoteEntry);\n      containerMap[remoteEntry] = container;\n    });\n  });\n}\n\nfunction loadRemoteScriptEntry(remoteEntry, remoteName) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      // Is remoteEntry already loaded?\n      if (containerMap[remoteName]) {\n        resolve();\n        return;\n      }\n\n      const script = document.createElement('script');\n      script.src = remoteEntry;\n      script.onerror = reject;\n\n      script.onload = () => {\n        const container = window[remoteName];\n        initRemote(container, remoteName);\n        containerMap[remoteName] = container;\n        resolve();\n      };\n\n      document.body.appendChild(script);\n    });\n  });\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction loadRemoteModule(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let loadRemoteEntryOptions;\n    let key;\n    let remoteEntry; // To support legacy API (< ng 13)\n\n    if (!options.type) {\n      options.type = 'script';\n    }\n\n    if (options.type === 'manifest') {\n      const manifestEntry = config[options.remoteName];\n\n      if (!manifestEntry) {\n        throw new Error('Manifest does not contain ' + options.remoteName);\n      }\n\n      options = {\n        type: manifestEntry.type,\n        exposedModule: options.exposedModule,\n        remoteEntry: manifestEntry.remoteEntry,\n        remoteName: manifestEntry.type === 'script' ? options.remoteName : undefined\n      };\n      remoteEntry = manifestEntry.remoteEntry;\n    } else {\n      remoteEntry = options.remoteEntry;\n    }\n\n    if (options.type === 'script') {\n      loadRemoteEntryOptions = {\n        type: 'script',\n        remoteEntry: options.remoteEntry,\n        remoteName: options.remoteName\n      };\n      key = options.remoteName;\n    } else if (options.type === 'module') {\n      loadRemoteEntryOptions = {\n        type: 'module',\n        remoteEntry: options.remoteEntry\n      };\n      key = options.remoteEntry;\n    }\n\n    if (remoteEntry) {\n      yield loadRemoteEntry(loadRemoteEntryOptions);\n    }\n\n    return yield lookupExposedModule(key, options.exposedModule);\n  });\n}\n\nfunction setManifest(manifest, skipRemoteEntries = false) {\n  return __awaiter(this, void 0, void 0, function* () {\n    config = parseConfig(manifest);\n\n    if (!skipRemoteEntries) {\n      yield loadRemoteEntries();\n    }\n  });\n}\n\nfunction getManifest() {\n  return config;\n}\n\nfunction loadManifest(configFile, skipRemoteEntries = false) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const result = yield fetch(configFile);\n\n    if (!result.ok) {\n      throw Error('could not load configFile: ' + configFile);\n    }\n\n    config = parseConfig(yield result.json());\n\n    if (!skipRemoteEntries) {\n      yield loadRemoteEntries();\n    }\n  });\n}\n\nfunction parseConfig(config) {\n  const result = {};\n\n  for (let key in config) {\n    const value = config[key];\n    let entry;\n\n    if (typeof value === 'string') {\n      entry = {\n        remoteEntry: value,\n        type: 'module'\n      };\n    } else {\n      entry = Object.assign(Object.assign({}, value), {\n        type: value.type || 'module'\n      });\n    }\n\n    result[key] = entry;\n  }\n\n  return result;\n}\n\nfunction loadRemoteEntries() {\n  return __awaiter(this, void 0, void 0, function* () {\n    const promises = [];\n\n    for (let key in config) {\n      const entry = config[key];\n\n      if (entry.type === 'module') {\n        promises.push(loadRemoteEntry({\n          type: 'module',\n          remoteEntry: entry.remoteEntry\n        }));\n      } else {\n        promises.push(loadRemoteEntry({\n          type: 'script',\n          remoteEntry: entry.remoteEntry,\n          remoteName: key\n        }));\n      }\n    }\n\n    yield Promise.all(promises);\n  });\n}\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { getManifest, loadManifest, loadRemoteEntry, loadRemoteModule, setManifest }; //# sourceMappingURL=angular-architects-module-federation-runtime.js.map","map":null,"metadata":{},"sourceType":"module"}